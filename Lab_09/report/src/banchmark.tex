\section{Тест производительности}
% {\itshape Тут Вы описываете собственно тест производительности, сравнение Вашей реализации с уже существующими и т.д.}

В тесте производительности сравним два алгоритма обхода графов: алгоритм Дейкстры и Беллмана-Форда.
В тестах не будет ребер с отрицательным весом.

Тестировать будем на графах с количеством вершин: 10, 20, 100, 1000, 10000.
Количество ребер будет примерно равно количеству вернин.

\begin{alltt}
alex@wega:~/$ ./wrapper.sh 
Stage #4 Benchmarking...
Dijkstra: 0.007 ms
Bellman-Ford: 0.005 ms
alex@wega:~/$ ./wrapper.sh
Stage #4 Benchmarking...
Dijkstra: 0.007 ms
Bellman-Ford: 0.009 ms
alex@wega:~/$ ./wrapper.sh
Stage #4 Benchmarking...
Dijkstra: 0.010 ms
Bellman-Ford: 0.542 ms
alex@wega:~/$ ./wrapper.sh
Stage #4 Benchmarking...
Dijkstra: 0.766 ms
Bellman-Ford: 21.985 ms
alex@wega:~/$ ./wrapper.sh
Stage #4 Benchmarking...
Dijkstra: 2.887 ms
Bellman-Ford: 2487.852 ms
\end{alltt}

Как видно, алгоритм Дейкстры является более производительным по сравнению с алгоритмом Беллмана-Форда.
Такой результат получается потому, что алгоритм Дейкстры использует жадный подход для поиска наименьшего пути.
Жадный подход позволяет решать задачу более эффективно. Мы стараемся взять ребро с наименьшим весом при помощи
очереди приоритетов. Алгоритм Беллмана-Форда будет проходить по графу, пока не пройдет $n-1$ итерацию, что 
является неэффективным при работе с большими графами.

\pagebreak
