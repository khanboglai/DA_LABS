\section{Описание}

Требуется реализовать алгоритм Дейкстры для поиска кратчайшего пути между двумя вершинами в неориентированном графе.

Согласно \cite{Kormen}: \enquote{Алгоритм Дейкстры решает задачу о кратчайшем пути из одной вершины во
взвешенном ориентированном графе $G = (V, E)$ в том случае, когда веса ребер
неотрицательны.}

Основным недостатком алгоритма Дейкстры является то, что он не работает с отрицательными весами ребер.
Алгоритм Дейкстры является наиболее популярным способом решения данной задачи, так как является более
производительным по сравнению с алгоритмом Беллмана-Форда.

Для решения задачи при помощи алгоритма Дейкстры, нужно задать расстояния от начальной вершины для всех остальных
вершин. Для начальной вершины это расстояние будет $0$ (расстояние до самой себя). Для остальных 
вершин это расстояние равно бесконечности (или числу, которое будет больше, чем максимально возможный вес ребра 
в графе). 

Далее нужно создать неубывающую очередь с приоритетом для работы с парами (вершина и ее вес). Сначала поместим 
в очередь начальную вершину. Достанем ее из очереди и проверяем, посетили мы ее или нет. После того, как достали
вершину, ее надо удалить из очереди. Дальше делаем ослабление ребер (релоксацию), исходящих из этой 
вершины. Если мы ослабили ребро, его надо добавить в очередь со своим новым весом. Так алгоритм учтёт изменения
 и сделает пересчет для всех ребер графа, которые с исходят из добавленной вершины. И так пока не пройдем весь граф.
Пока не выполним обход в ширину.

Как только очередь станет пустой, значит алгоритм закончил свою работу и мы нашли кратчайшие пути в графе.

\pagebreak

\section{Исходный код}
% Здесь должно быть подробное описание программы и основные этапы написания кода.

Для начала определим тип данных для графа. Граф можно представить как матрицу (матрицу смежности). 
В языке программирования C++ это вектор векторов из пар (вершина и вес пути до нее).

Также необходимо задать бесконечность для корректной реализации алгоритма.

Для считывания графа из стандартного потока ввода запустим цикл по количеству ребер $m$ и добавим в граф
введеную информацию. Стоит отметить, что в условии задачи дан неориентированный граф, значит нужно добавить 
путь как из $u \to v$, так и из $v \to u$.

После, создадим вектор расстояний для каждой вершины и инициализируем его значениями бесконечности.

Важно отметить, что мы используем индексы с $0$, поэтому нужно вычесть из каждого значения вершины $1$.

Передадим в функцию для алгоритма Дейкстры граф, стартовую и конечную вершины, и вектор расстояний.

В функции алгоритма заменим расстояние от старотовой вершины до самой себя на $0$. Создадим очередь с 
неубывающим порядком, которая будет принимать пару (вес, вершина). Такая структура пары поможет 
правильно сортировать вершины по весам внутри очереди. Далее добавляем в очередь стартовую вершину с весом $0$.

Достаем из очереди вершину и начинаем проход по графу ослабляя ребра ее соседей (делаем релоксацию). И делаем
так, пока не дойдем до конечной вершины.

Для вывода результата нужно проверить, если вес последней вершины равен бесконечности, то мы не можем до нее дойти.
Иначе нужно вывести рещультат.
% В этом случае структуры или классы должны быть полностью приведены в листинге (без реализации методов).

\begin{lstlisting}[language=C]
#include <bits/stdc++.h>

const int64_t INF = 1e18;
using graph = std::vector<std::vector<std::pair<int, int64_t>>>;
using g_item = std::pair<int64_t, int>;


void dijkstra(const graph &g, int u, int f, std::vector<int64_t> &d) {
    d[u] = 0;
    std::priority_queue<g_item, std::vector<g_item>, std::greater<g_item>> pq;
    pq.push(std::make_pair(0, u));

    while (!pq.empty()) {
        g_item current = pq.top();
        pq.pop();

        u = current.second;
        
        if (u == f) {
            break;
        }

        if (current.first > d[u]) {
            continue;
        }

        for (size_t i = 0; i < g[u].size(); i++) {
            int v = g[u][i].first;
            int64_t w = g[u][i].second;

            if (d[u] + w < d[v]) {
                d[v] = d[u] + w;
                pq.push(std::make_pair(d[v], v));
            }
        }
    }

    if (d[f] != INF) {
        std::cout << d[f] << std::endl;
    } else {
        std::cout << "No solution\n";
    }
}


int main() {
    int n, m, start, finish;
    std::cin >> n >> m >> start >> finish;
    graph g(n);

    for (int i = 0; i < m; i++) {
        int u, v;
        int64_t w;
        std::cin >> u >> v >> w;
        u--;
        v--;
        g[u].push_back(std::make_pair(v, w));
        g[v].push_back(std::make_pair(u, w));
    }

    std::vector<int64_t> d(n, INF);
    start--;
    finish--;

    dijkstra(g, start, finish, d);
    return 0;
}
\end{lstlisting}


\pagebreak

\section{Консоль}
\begin{alltt}
alex@wega:~/$ cat test.txt 
5 6 1 5
1 2 2
1 3 0
3 2 10
4 2 1
3 4 4
4 5 5
alex@wega:~/$ ./main < test.txt 
8
alex@wega:~/$ cat tests/test_1.t 
20 25 13 6
1 19 12
9 20 84
6 10 38
4 12 91
11 14 29
3 20 79
4 20 12
11 20 41
8 17 66
11 13 17
5 11 64
19 20 8
1 3 63
9 14 85
7 10 9
7 10 67
10 12 5
5 10 28
16 18 50
6 13 44
17 18 70
7 18 58
4 5 89
11 15 46
14 20 84
alex@wega:~/$ ./main < tests/test_1.t 
44
alex@wega:~/$ ./main
3 1 2 3
1 2 5
No solution
\end{alltt}
\pagebreak
