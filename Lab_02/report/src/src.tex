\section{Описание}
Требуется написать реализацию словоря с помощью B-дерева. Нужно реализовать основные операции (вставка, удаление, поиск) и 
операции работы с диском (запись данных на диск, чтение данных с диска).


Как сказано в \cite{wiki_abstract}: \enquote{B-дерево (англ. B-tree) — сильноветвящееся идеально сбалансированное дерево поиска.}.


Сильноветвящееся дерево - каждый узел B-дерева может иметь много дочерних узлов, для этого у B-дерева есть парамметр $t$, 
называемый минимальной степенью B-дерева ($t >= 2$). Данный параметр отвечает за ветвление дерева.


Сбалансированное дерево - дерево, для которого выполняется следующее свойство: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.
Так как B-дерево является идеально сбалансированным, то для каждой вершины высота её двух поддеревьев будет одинакова.

\vspace{2\baselineskip}
Свойства B-дерева:

\begin{enumerate}
    \item Каждый узел, кроме корня, содержит от $t-1$ до $2t-1$ ключей. Корень содержит от $1$ до $2t-1$ ключей. 
    \item Ключи в каждом узле упорядочены по неубыванию (для быстрого доступа к ним).
    \item Каждый узел дерева, кроме листьев, содержащий ключи $K_1$, ..., $K_n$, имеет $n+1$ потомка. Причем
    
    \begin{itemize}
        \item Первый дочерний узел будет содержать числа в диапазоне ($-\infty$, $K_1$).
        \item $n+1$ дочерний узел будет содержать числа в диапазоне ($K_n$, $\infty$).
        \item Дочерние узлы, находящиеся между первым и последним элменетом, будут сожержать числа в диапазоне ($K_{i-1}$, $K_i$).
    \end{itemize}

    \item Все листья находятся на одном уровне.
\end{enumerate}


Поиск в B-дереве очень похож на поиск в бинарном дереве поиска. Отличие в том, что в бинарном дереве поиска вибирали один из двух путей, 
в B-дереве выбираем из интервала. Если ключ содержится в узле, то он найден, иначе продолжаем поиск.


Вставка в B-дерево сложнее, чем вставка в бинарное дерево поиска, так как нам нужно соблюдать свойства B-дерева. 
Нельзя создавать узле для вставки, как это принято в бинарном дереве поиска. Вместо этого, мы должны вставлять элемент в уже существующий узел.
Но при этом важно проверять, что узел не заполнился ($2t-1$ элементов в узле). Если же узел заполнен, то его нужно разбить.

Для этого у нас есть операция разбиения. Заполненный узел делим на два узла, в каждом их готорых $t-1$ ключ. 
Средний ключ перемещается в родительский узел, он будет разделительной точкой для двух новых узлов. Может произойти ситуация, 
когда родительский узел тоже будет заполнен. Его тоже нужно разделить.

Вставку в B-дерево можно осуществить за один проход от корня к листу. 
При проходе в поисках нужной позиции от корня к листу будем разделять все заполненные узлы. Так мы сможем гаранитировать, 
что при разделении ккого-то узла, родительский узел не будет заполнен.


Аналогично вставке нужно проверять, что выполняются свойства B-дерева. Проще всего удалить ключ из листа, 
главное проверить, что в листе больше, чем $t-1$ элемент. Иначе придется брать ключ у левого или правого брата. Опять же проверяя, 
что для брата выполняется свойство 1. Если же и в братьях по $t-1$ элементу, то нужно объединить текущий узел и брата с родительским узлом.
В новом узле станет $2t-1$ элемента. Теперь можно удалить элемент.
В случае с удаление из внутреннего узла нужно найти предшественника или преемника, 
если предшественник или преемник содержит больше, чем $t-1$ ключ, то заменяем исходный удаляемый ключ на последний из предшественника или на первый из преемника,
после чего удаляем найденный ключ из предшественника или преемника.
Если же предшественник и преемник содержат по $t-1$ ключу, то нужно объединить их с родительским узлом и удалить исходный элемент.

Удаление просиходит за один проход по дереву, но при удаленни ключа из внутреннего узла может потребоваться возврат к узлу, 
ключ из которого был удален и замещен его предшественником или последующим за ним ключом.


Так как дерево идеально сбалансированно, опреации с деревом выполняются за $O(h)$ ($h$ - высота дерева).


Согласно \cite{Kormen} : \enquote{Пусть B-дерево имеет высоту $h$. Корень дерева содержит как
минимум один ключ, а все остальные узлы — как минимум по $t - 1$ ключей.
Таким образом, имеется как минимум 2 узла на глубине 1, как минимум $2t$ узлов
на глубине 2, как минимум $2t^2$ узлов на глубине 3 и т.д., до глубины $h$, на которой
имеется как минимум $2t^{h-1}$ узлов. Следовательно, число ключей $n$ удовлетворяет следующему
неравенству:

$$n >= 1 + (t-1)\sum_{i=1}^{h}2t^{i-1} = 1 + 2(t-1)(\frac{t^h-1}{t-1})=2t^h-1$$}.

Логорифмируем по основанию $t$:
$$h <= \log_{t}{\frac{n+1}{2}}$$

Так как $t$ - константа, то можем записать неравенсво так:
$$h <= \log n$$

Все операции с деревом принимают сложность $O(\log n)$.


Для записи дерева в файл, спускаем по дереву от корня к листьям, при этом записываем в файл узлы, вместе с информацией о них, 
слева направо в бинарном представлении. То есть пишем в файл текущий узел, после записываем его дочерние узлы, в порядке их следования. Если узел пустой, 
то мы ничего не пишем. 
Для чтения дерева из файла, создаем пустой узел и записываем в него прочитанные данные, после чего по порядку читаем и записваем информацию о его дочерних узлах.
Если узел был пустой, то записываем нулевой указатель.
Сложность операций $O(n)$.


\pagebreak

\section{Исходный код}
% Здесь должно быть подробное описание программы и основные этапы написания кода.

Узел B-дерева состоит из нескольких ключей и указательей на дочерние узлы. Для хранения ключей и указательей на дочерние узлы будем использовать
динамический массив. Так как степень (характеристичекое число) $t$ B-дерева не меняется, то для написания дерева динамического массива
будет достаточно. С его помощью мы сможем легко разделить и объединить узлы, и найти нужный ключ.

Узел дерева хранит массив ключей и массив указателей на дочерние узлы.

\begin{lstlisting}[language=C]
struct TNode {
    int n;
    TElem* el;
    TNode** children;
    bool leaf;

    static TElem* Search(TNode *TNode, std::string key);
    static TElem FindSuccessor(TNode *TNode);
    static TElem FindPredecessor(TNode *TNode);
};
\end{lstlisting}


Методы для узла

\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {btree.hpp}\\
\hline
TElem FindSuccessor(TNode *node)&Поиск преемника, для удаления из внутреннего узла\\
\hline
\hline
TElem FindPredecessor(TNode *node)&Поиска предшественника, для удаления из внутреннего узла\\
\hline
\hline
TElem* Search(TNode *node, std::string key)&Поиск узла\\
\hline
\end{longtable}


Методы для класса
% В случае, если код не помещается на одну-две страницы $A4$, тогда следует сделать табличку следующего вида:
\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {btree.hpp}\\
\hline
TNode *AllocateTNode()&Выделение памяти для узла\\
\hline
\hline
void Deallocate(TNode *node)&Освобождение памяти, выделенной под узел\\
\hline
\hline
void DeleteTree(TNode *node)&Удаление дерева\\
\hline
\hline
bool Search(std::string key)&Поиск ключа\\
\hline
\hline
void SplitChild(TNode *empty{\_}node, int i, TNode *em{\_}node{\_}child)&Разбиение узла\\
\hline
\hline
void Insert(TElem elem)&Вставка элемента в дерево\\
\hline
\hline
void InsertNonfull(TNode *not{\_}full{\_}node, TElem elem)&Вставка элемента в неполный узел\\
\hline
\hline
TNode *MergeTNodes(TNode *parent, TNode *left{\_}child, TNode *right{\_}child, int i)&Объединение узлов\\
\hline
\hline
bool Delete(std::string key)&Удаление элемента из дерева\\
\hline
\hline
bool DeleteFromTNode(TNode *node, std::string key)&Удаление элемента из узла\\
\hline
\hline
std::string SWV(std::string key)&Поиск со значением, для задания\\
\hline
\hline
void WriteInFile(TNode *node, std::ofstream{\&} os)&Запись дерева в файл\\
\hline
\hline
TNode *LoadFromFile(std::ifstream{\&} in)&Чтение дерева из файла\\
\hline
\hline
void Save(std::ofstream{\&} os)&Обертка для функции записи в файл\\
\hline
\hline
void Load(std::ifstream{\&} in)&Обертка для функции чтения из файла\\
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {main.c}\\
\hline
std::string ToLower(std::string str)&Функция для преобразования в нижний регистр\\
\hline
\end{longtable}
% В этом случае структуры или классы должны быть полностью приведены в листинге (без реализации методов).

Для удобтва, напишем структуру для хранения пары ключ-значение.

Листинг
\begin{lstlisting}[language=C]
struct TElem {
    std::string key;
    uint64_t value;
};


class TBTree {
    private:
        struct TNode {
            int n;
            TElem* el;
            TNode** children;
            bool leaf;

            static TElem* Search(TNode *node, std::string key);
            static TElem FindSuccessor(TNode *node);
            static TElem FindPredecessor(TNode *node);
        };

        TNode *AllocateTNode();
        void Deallocate(TNode *node);
        void DeleteTree(TNode *node);

        void SplitChild(TNode *parent, int index, TNode* child);
        TNode *MergeTNodes(TNode *parent, TNode *left_child, TNode *right_child, int i);
        
        void InsertNonfull(TNode *node, TElem elem);
        bool DeleteFromTNode(TNode *node, std::string key);

        void WriteInFile(TNode *node, std::ofstream& os);
        TNode *LoadFromFile(std::ifstream& in);

        TNode *root;
        int t;

    public:
        TBTree();
        ~TBTree();

        void Insert(TElem TElem);
        bool Delete(std::string key);
        bool Search(std::string key);
        void Save(std::ofstream& os);
        void Load(std::ifstream& in);
        std::string SWV(std::string key);
};
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ make
g++ -std=c++20 -pedantic -Wall -Wextra -Werror -g main.cpp -o lab2
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ cat tests/test.t 
+ English 5
! Save Subj.txt
+ PE 35304034
+ Science 5673934
Math
! Load Subj.txt
+ Math 8388923492
+ History 123456
Math
English
- History
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ ./lab2 < tests/test.t 
OK
OK
OK
OK
NoSuchWord
OK
OK
OK
OK: 8388923492
OK: 5
OK
\end{alltt}
\pagebreak
