\section{Тест производительности}
% {\itshape Тут Вы описываете собственно тест производительности, сравнение Вашей реализации с уже существующими и т.д.}


Сравним скорость работы B-дерева с $std::map$. Ключи будут иметь тип $std::string$, а значения $uint64\_t$.
В $std::map$ не реализованна работа с файлами, поэтому будем тестировать только опреации поиска, вставки и удаления.
Степень дерева равна 4.
Для измерений возьмем следующие наборы тестов: 1000 строк, 10000 строк, 100000 строк, 500000 строк.

\begin{alltt}
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ make benchmark 
g++ -std=c++20 -pedantic -Wall -Wextra -Werror -g benchmark.cpp -o benchmark
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ ./benchmark < tests/1000.t 
Btree: 1.251 ms
Map: 0.673 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ ./benchmark < tests/10000.t 
Btree: 17.181 ms
Map: 8.997 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ ./benchmark < tests/100000.t 
Btree: 218.552 ms
Map: 117.412 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_02$ ./benchmark < tests/500000.t 
Btree: 1171.639 ms
Map: 649.296 ms
\end{alltt}

В основе $std::map$ лежит красно-черное дерево. Так как мы работаем преимущественно с опреативной памятью, 
то красно-черное дерево будет более эффективным, потому что не требует большого числа копирований.
В B-дереве мы теряем время на операциях разбиения и объединения, так как копируем элементы из одного массива в другой.
Во время операций поиска, вставки и удаления мы проходим по дереву циклом, что тоже занимает время.

\pagebreak
