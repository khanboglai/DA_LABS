\section{Описание}

Требуется реализовать алгоритм Укконена для построения суффиксного дерева за линенйное время.


Согласно \cite{Gasfild}: \enquote{Алгоритм Укконена строит неявное суффиксное дерево $\tau_i$ для каждого префикса $S[1..i]$ строки $S$, 
начиная с $\tau_1$ и увеличивая $i$ на единицу, пока не будет построено $\tau_n$. 
Настоящее суффиксное дерево для $S$ получается из $\tau_n$, и вся работа требует времени O$(n)$.}

Начинают знакомство с алгоритмом Укконена с наивной реазизации, имеющей сложность O($n^3$). А после пытаются ускорить алгоритм,
чтобы сложность стала O($n$).

В чем же проблема алгоритма за O($n^3$)? 

Вместо того, чтобы вставить все суффиксы строки, происходит вставка суффиксов всех префиксов строки.
Для поиска и вставки элемента каждый раз осуществляем проход из корня. Алгоритм не эффективен по памяти, 
так как на ребре хранятся символы строки.

Для ускорения алгоритма будем строить все суффиксы строки, чтобы избежать большого числа повторений, 
как это было в алгоритме за O($n^3$).

Допустим, в суффиксном дереве есть строка $x\alpha$, где $x$ - первый символ строки, 
а $\alpha$ - оставшаяся подстрока (возможно пустая). Значит в суффиксном дереве есть и строка $\alpha$. 
Пусть для строки $x\alpha$ есть внутрення вершина $v$, тогда для строки $\alpha$ существует внутреняя вершина $p$.
Значит из $v$ в $p$ поможно постоить \enquote{путь}, который называется суффиксной ссылкой. В программной реализации суффиксная ссылка
будет являться указателем из $v$ в $p$.

Суффиксные ссылки позволяют перемещаться по дереву быстрее, так как нам известно, 
какие символы будут находится на ребре до внутренней вершины, значит можно не делать проход из корня (можно не делать повторное сравнение). 
Чтобы построить суффиксную ссылку, нужно хранить указатель на последную внутренню вершину, и, 
когда мы создадим новую внутреннюю вершину, необходимо связать ее с последней.

Но это еще не все, для ускорения алгоритма, надо избегать повторных сравнений.

Чтобы перейти по суффиксной сслыке, нужно перейти по ребру до ближайшей внутренней вершины, а после пройти такое же количество 
символов, после перемещения по ссылке. Ибежать лишних сравнений помогут \enquote{прыжки по счётчикам}. Будем считать, сколько символов на ребре 
было пройдено, до перехода по суффиксной ссылке, и столько же символов \enquote{перепрыгнем} после перехода.

Теперь сложность алгоритма будет составлять O($n^2$). Причиной всему память, которая затрачивается на хранение символов на ребре.
На данных момент на ребре хранися подстрока. Значит символы идут подряд. Тогда можно хранить только индекс начала 
и конеца подстроки на каждом ребре. При добавлении нового символа на ребро будем увеличивать индекс конца подстроки для всего дерева.
Такое \enquote{продление} суффиксов в среднем работает за O($1$).

Если использовать все вышеописанные эвристики, то алгоритм Укконена будет иметь сложность O($n$).


\pagebreak

\section{Исходный код}
% Здесь должно быть подробное описание программы и основные этапы написания кода.
Для реализации аллгоритма Укконена опишем необходимо написать класс для суффиксного дерева $TSuffixTree$. Дерево состоит из узлов, 
значит напишим класс для узла $TNode$. Также у дерева есть параметры, котрые мы должны хранить для правильного построения.
Напишем структуру для хранения параметров $TreeData$. 


% В этом случае структуры или классы должны быть полностью приведены в листинге (без реализации методов).

\begin{lstlisting}[language=C]
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>


const char SENTINEL = '$';
const int TERMPOS = -1;
const int TERMVAL = 0;
const bool ISLEAF = true;


class TSuffixTree {
    private:
        class TNode {
            public:
                int begin; // start curve
                int *end; // end curve, ptr, for change
                TNode *suffix_link; // suffix link
                bool is_leaf; // node status
                std::unordered_map<char, TNode *> child; // child

                TNode(int start, int *finish, TNode* s_link, bool leaf); // node constructor
        };

        struct TreeData {
            TNode *current_node; 
            int current_index;
            int jump_counter;
            int plannedSuffixs;
        };


        TNode *root; 
        std::string str; 
        int suffixTreeEnd;
        TreeData params; 

        void CreateTree();
        void AddSuffix(int position); 
        void DestroyTree(TNode *node);
        int CurveLength(TNode *node);
        void SplitNode(TNode *node, int position, TNode *last_inner_node);

    public:
        TSuffixTree(std::string &input_str);
        ~TSuffixTree();
        void MatchStatistic(std::vector<int> &ms, const std::string &str); 
};
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}

\end{alltt}
\pagebreak
