\section{Описание}

Требуется реализовать поиск одного образца основнанный на построении z-блоков. Учитывая, что алфавит состоит из чисел,
нужно преобразовать "слово" в число. При работе с числами мы не можем использовать привычные нам разделители:
\#, \$.


Согласно \cite{Gasfild}: \enquote{Z-функция - это длина наибольшей подстроки $S$, которая начинается в $i$ и совпадает с префиксом $S$.}

Есть два вида алгоритма Z-функуции: наивный за $O(n^2)$ и эффективный за $O(\mid S \mid)$, где $S$ - строка.
Для выполнения лабораторной работы нужно использовать эффективную версию алгоритма, 
иначе можем превысить ограничения для программы по памяти и по времени.


В основе эффективного алгоритма лежат Z-блоки. Согласно \cite{Gasfild} Z-блок - это подстрока с началом в позиции $i$
и длиной $Z[i]$. Для работы алгоритма нужно завести две переменные: $l$ и $r$, левая и правая границы Z-блока.
Изначально эти переменный равны $0$.


Пусть нам известны значения Z-функции от $0$ до $i-1$. Найдём $Z[i]$. 

Рассмотрим два случая:

1. $i > r$

Просто пробегаемся по строке $S$ и сравниваем символы на позициях $S[i+j]$ и $S[j]$.Пусть $j$ первая позиция 
в строке $S$ для которой не выполняется равенство $S[i + j] = S[j]$, тогда $j$ это и Z-функция для позиции $i$. 
Тогда $l = i$, $r = i + j - 1$. В данном случае будет определено корректное значение $Z[i]$
в силу того, что оно определяется наивно, путем сравнения с начальными символами строки.

2. $i <= r$

Сравним $Z[i-l] + i$ и $r$. Если $r$ меньше, то надо просто наивно пробежаться по строке начиная с 
позиции $r$ и вычислить значение $Z[i]$. Корректность в таком случае также гарантирована. 
Иначе мы уже знаем верное значение $Z[i]$, так как оно равно значению $Z[i-l]$.


Данный алгоритм эффективнее предыдущего, так как мы не вычисляем Z-функцию для каждого элемента, только для некоторых
символов (чисел). А остальные Z-функции можем получить на основе предыдущих Z-функций.

Алгоритм Z-функции посещает каждый элемент не более двух раз. Его сложность $O(n + m)$, где $m$ - длина текста,
а $n$ - длина паттерна.


\pagebreak

\section{Исходный код}
% Здесь должно быть подробное описание программы и основные этапы написания кода.

Для выполнения работы нам подтребуется: написать Z-функцию, реализовать ввод и вывод данных, поиск подстроки в строке.
А также провести тесты производительности.


Входной файл содержит числа, которые нужно рассматривать, как слова в тексте. Для вывода результата,
необходимо знать номер строки, в которой найдено совпадение и номер слова в строке, с которого начинается совпадение.

Для этого определим вектор, элемент которого это пара, состоящая из числа и пары (номер слова и номер строки).
Объявим псевдоним $TDigitSRH$, чтобы упростить работу с программой и сделать ее код более разборчивым.


Так как на вход подаются строки, то их надо преобразовать в вектор чисел.


Также создадим переменную $SEP$, эта переменная нужна для реализации поиска подстроки в строке.
Чтобы найти паттерн в тексте, соединим паттерн с текстом в один вектор, а между ними поместим разделитель.
Исходный алфавит состоит из числе от $0$ до $2^{32} - 1$, значит нужно взять в качестве разделителя такое число,
которое не встретится ни в паттерне, ни в тексте.

Таким числом является любое отрицательное число, например $-1$, подходящее под наш тип данных. 

Так как мы используем отрицательные числа,
то нам уже не подойдет тип $uint32\_t$, нужно брать $int64\_t$.


Далее для нового вектора подсчитаем Z-функцию. Если $Z[i] == n$, ($n$ - длина паттерна), то мы нашли вхождение
паттерна в текст. 

Главное учесть, что цикл, для прохода по Z-функции, нужно начинать не с $0$, а с $n + 1$, 
так как в начале нашего вектора находится паттерн и разделитель.


% В этом случае структуры или классы должны быть полностью приведены в листинге (без реализации методов).

\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <sstream>


const int SEP = -1; 
using TDigitSRH = std::pair<int64_t, std::pair<size_t, size_t>>;


std::vector<int> Z_func(const std::vector<TDigitSRH>& S) {
    int n = S.size();
    int l = 0, r = 0;
    std::vector<int> Z(n);

    for (int i = 1; i < n; i++) {
        
        Z[i] = std::max(0, std::min(r - i, Z[i - l]));

        while (i + Z[i] < n && S[Z[i]].first == S[i + Z[i]].first) { 
            Z[i]++;
        }
        
        if (i + Z[i] > r) {
            l = i;
            r = i + Z[i];
        }
    }

    return Z;
}


int main() {
    std::string P;
    getline(std::cin, P);
    std::vector<TDigitSRH> vec_p;
    
    
    std::istringstream ss(P);
    int64_t number = 0;
    size_t cnt_n = 0;
    while (ss >> number) {
        vec_p.push_back(std::make_pair(number, std::make_pair(cnt_n, 1)));
        cnt_n++;
    }

    int p_sz = vec_p.size();
    TDigitSRH sep_elem = std::make_pair(SEP, std::make_pair(vec_p.size(), 1));

    vec_p.push_back(sep_elem);

    
    std::string T;
    size_t cnt_line = 1;
    
    while (getline(std::cin, T)) {
        
        std::istringstream ss(T);
        int64_t num = 0;
        size_t cnt_num = 0;
        while (ss >> num) {
            vec_p.push_back(std::make_pair(num, std::make_pair(cnt_num, cnt_line)));
            cnt_num++; 
        }
        cnt_line++;
    }


    std::vector<int> Z = Z_func(vec_p);

    for (size_t i = p_sz + 1; i < Z.size(); i++) {
        if (Z[i] == p_sz) {
            std::cout << vec_p[i].second.second << ", " << vec_p[i].second.first + 1 << std::endl;
        }
    }
}
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ cat tst.txt 
51 89 51 89 122
0051 89 051 89 51 89 122    51
89 51 89 122
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ g++ -std=c++17 -pedantic -Wall -Wextra -Werror main.cpp 
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ ./a.out < tst.txt 
1, 3
1, 8
\end{alltt}
\pagebreak
