\section{Тест производительности}
% {\itshape Тут Вы описываете собственно тест производительности, сравнение Вашей реализации с уже существующими и т.д.}

Реализованный алгоритм Z-функции сравним с наивным алгоритмом Z-функции.

Будем тестировать на последовтельности из: $10^3$, $10^4$, $10^5$, $10^6$.


\begin{alltt}
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ g++ -std=c++17 -pedantic -Wall -Wextra -Werror bechmark.cpp
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ ./a.out < tests/1
Z\_naive: 0.026 ms
Z\_effective: 0.050 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ ./a.out < tests/2
Z\_naive: 0.365 ms
Z\_effective: 0.440 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ ./a.out < tests/3
Z naive: 21.339 ms
Z effective: 18.047 ms
alex@wega:~/Рабочий стол/вуз/2course/da_labs/Lab_04$ ./a.out < tests/4
Z naive: 40.037 ms
Z effective: 19.681 ms
\end{alltt}


На первых тестах наивная Z-функция работает быстрее. Это связано с тем, что в ней нет дополнительных проверок, 
как в эффективной Z-функции, где мы проверяем правую границу Z-блока.
Видно, что стандартная Z-функция работает медлее с большими текстами, Так как она вычисляет значение 
для каждого символа. Эффективная Z-функция использует значения уже рассчитанные, посещая каждую позицию не более 
двух раз,что для больших текстов является более эффективным.


\pagebreak
